
/*
 * @typedef {{
 * isDynamic?: boolean; 
 * recordOptions: {[recordType: string | RecordTypeEnum]: {
 * idOptions: idSearchOptions[],
 * responseOptions: ResponseOptions,
 * }}}} GetRecordRequest
*/

/*
 * @typedef {{
 * status: number;
 * message: string;
 * error?: string;
 * logArray: LogStatement[];
 * records: {
 * [recordType: string | RecordTypeEnum]: {
 * results: Array<GetRecordResult>; 
 * rejects: Array<idSearchOptions>
 * }};
 * }} GetRecordResponse
*/

--------
/**
 * @enum {string} RecordTypeEnum
 * @readonly
 * @description supported NetSuite API record types As of 4 June 2024
 * @reference ~\node_modules\@hitc\netsuite-types\N\record.d.ts
 * 
 * @property {string} ACCOUNT - account
 * @property {string} ACCOUNTING_BOOK - accountingbook
 * @property {string} ACCOUNTING_CONTEXT - accountingcontext
 * @property {string} ACCOUNTING_PERIOD - accountingperiod
 * @property {string} ADV_INTER_COMPANY_JOURNAL_ENTRY - advintercompanyjournalentry
 * @property {string} ALLOCATION_SCHEDULE - allocationschedule
 * @property {string} AMORTIZATION_SCHEDULE - amortizationschedule
 * @property {string} AMORTIZATION_TEMPLATE - amortizationtemplate
 * @property {string} ASSEMBLY_BUILD - assemblybuild
 * @property {string} ASSEMBLY_ITEM - assemblyitem
 * @property {string} ASSEMBLY_UNBUILD - assemblyunbuild
 * @property {string} AUTOMATED_CLEARING_HOUSE - automatedclearinghouse
 * @property {string} BALANCE_TRX_BY_SEGMENTS - balancetrxbysegments
 * @property {string} BILLING_ACCOUNT - billingaccount
 * @property {string} BILLING_CLASS - billingclass
 * @property {string} BILLING_RATE_CARD - billingratecard
 * @property {string} BILLING_REVENUE_EVENT - billingrevenueevent
 * @property {string} BILLING_SCHEDULE - billingschedule
 * @property {string} BIN - bin
 * @property {string} BIN_TRANSFER - bintransfer
 * @property {string} BIN_WORKSHEET - binworksheet
 * @property {string} BLANKET_PURCHASE_ORDER - blanketpurchaseorder
 * @property {string} BOM - bom
 * @property {string} BOM_REVISION - bomrevision
 * @property {string} BONUS - bonus
 * @property {string} BONUS_TYPE - bonustype
 * @property {string} BUDGET_EXCHANGE_RATE - budgetexchangerate
 * @property {string} BULK_OWNERSHIP_TRANSFER - bulkownershiptransfer
 * @property {string} BUNDLE_INSTALLATION_SCRIPT - bundleinstallationscript
 * @property {string} CALENDAR_EVENT - calendarevent
 * @property {string} CAMPAIGN - campaign
 * @property {string} CAMPAIGN_RESPONSE - campaignresponse
 * @property {string} CAMPAIGN_TEMPLATE - campaigntemplate
 * @property {string} CARDHOLDER_AUTHENTICATION - cardholderauthentication
 * @property {string} CASH_REFUND - cashrefund
 * @property {string} CASH_SALE - cashsale
 * @property {string} CHARGE - charge
 * @property {string} CHARGE_RULE - chargerule
 * @property {string} CHECK - check
 * @property {string} CLASSIFICATION - classification
 * @property {string} CLIENT_SCRIPT - clientscript
 * @property {string} CMS_CONTENT - cmscontent
 * @property {string} CMS_CONTENT_TYPE - cmscontenttype
 * @property {string} CMS_PAGE - cmspage
 * @property {string} COMMERCE_CATEGORY - commercecategory
 * @property {string} COMPETITOR - competitor
 * @property {string} CONSOLIDATED_EXCHANGE_RATE - consolidatedexchangerate
 * @property {string} CONTACT - contact
 * @property {string} CONTACT_CATEGORY - contactcategory
 * @property {string} CONTACT_ROLE - contactrole
 * @property {string} COST_CATEGORY - costcategory
 * @property {string} COUPON_CODE - couponcode
 * @property {string} CREDIT_CARD_CHARGE - creditcardcharge
 * @property {string} CREDIT_CARD_REFUND - creditcardrefund
 * @property {string} CREDIT_MEMO - creditmemo
 * @property {string} CURRENCY - currency
 * @property {string} CUSTOMER - customer
 * @property {string} CUSTOMER_CATEGORY - customercategory
 * @property {string} CUSTOMER_DEPOSIT - customerdeposit
 * @property {string} CUSTOMER_MESSAGE - customermessage
 * @property {string} CUSTOMER_PAYMENT - customerpayment
 * @property {string} CUSTOMER_PAYMENT_AUTHORIZATION - customerpaymentauthorization
 * @property {string} CUSTOMER_REFUND - customerrefund
 * @property {string} CUSTOMER_STATUS - customerstatus
 * @property {string} CUSTOMER_SUBSIDIARY_RELATIONSHIP - customersubsidiaryrelationship
 * @property {string} CUSTOM_PURCHASE - custompurchase
 * @property {string} CUSTOM_RECORD - customrecord
 * @property {string} CUSTOM_SALE - customsale
 * @property {string} CUSTOM_TRANSACTION - customtransaction
 * @property {string} DEPARTMENT - department
 * @property {string} DEPOSIT - deposit
 * @property {string} DEPOSIT_APPLICATION - depositapplication
 * @property {string} DESCRIPTION_ITEM - descriptionitem
 * @property {string} DISCOUNT_ITEM - discountitem
 * @property {string} DOWNLOAD_ITEM - downloaditem
 * @property {string} EMAIL_TEMPLATE - emailtemplate
 * @property {string} EMPLOYEE - employee
 * @property {string} EMPLOYEE_CHANGE_REQUEST - employeechangerequest
 * @property {string} EMPLOYEE_CHANGE_REQUEST_TYPE - employeechangerequesttype
 * @property {string} EMPLOYEE_EXPENSE_SOURCE_TYPE - employeeexpensesourcetype
 * @property {string} EMPLOYEE_STATUS - employeestatus
 * @property {string} EMPLOYEE_TYPE - employeetype
 * @property {string} ENTITY_ACCOUNT_MAPPING - entityaccountmapping
 * @property {string} ESTIMATE - estimate
 * @property {string} EXPENSE_AMORTIZATION_EVENT - expenseamortizationevent
 * @property {string} EXPENSE_CATEGORY - expensecategory
 * @property {string} EXPENSE_PLAN - expenseplan
 * @property {string} EXPENSE_REPORT - expensereport
 * @property {string} EXPENSE_REPORT_POLICY - expensereportpolicy
 * @property {string} FAIR_VALUE_PRICE - fairvalueprice
 * @property {string} FINANCIAL_INSTITUTION - financialinstitution
 * @property {string} FIXED_AMOUNT_PROJECT_REVENUE_RULE - fixedamountprojectrevenuerule
 * @property {string} FOLDER - folder
 * @property {string} FORMAT_PROFILE - formatprofile
 * @property {string} FULFILLMENT_REQUEST - fulfillmentrequest
 * @property {string} GENERAL_TOKEN - generaltoken
 * @property {string} GENERIC_RESOURCE - genericresource
 * @property {string} GIFT_CERTIFICATE - giftcertificate
 * @property {string} GIFT_CERTIFICATE_ITEM - giftcertificateitem
 * @property {string} GL_NUMBERING_SEQUENCE - glnumberingsequence
 * @property {string} GLOBAL_ACCOUNT_MAPPING - globalaccountmapping
 * @property {string} GLOBAL_INVENTORY_RELATIONSHIP - globalinventoryrelationship
 * @property {string} GOAL - goal
 * @property {string} IMPORTED_EMPLOYEE_EXPENSE - importedemployeeexpense
 * @property {string} INBOUND_SHIPMENT - inboundshipment
 * @property {string} INTERCOMP_ALLOCATION_SCHEDULE - intercompallocationschedule
 * @property {string} INTER_COMPANY_JOURNAL_ENTRY - intercompanyjournalentry
 * @property {string} INTER_COMPANY_TRANSFER_ORDER - intercompanytransferorder
 * @property {string} INVENTORY_ADJUSTMENT - inventoryadjustment
 * @property {string} INVENTORY_COST_REVALUATION - inventorycostrevaluation
 * @property {string} INVENTORY_COUNT - inventorycount
 * @property {string} INVENTORY_DETAIL - inventorydetail
 * @property {string} INVENTORY_ITEM - inventoryitem
 * @property {string} INVENTORY_NUMBER - inventorynumber
 * @property {string} INVENTORY_STATUS - inventorystatus
 * @property {string} INVENTORY_STATUS_CHANGE - inventorystatuschange
 * @property {string} INVENTORY_TRANSFER - inventorytransfer
 * @property {string} INVENTORY_WORKSHEET - inventoryworksheet
 * @property {string} INVOICE - invoice
 * @property {string} INVOICE_GROUP - invoicegroup
 * @property {string} ISSUE - issue
 * @property {string} ISSUE_PRODUCT - issueproduct
 * @property {string} ISSUE_PRODUCT_VERSION - issueproductversion
 * @property {string} ITEM_ACCOUNT_MAPPING - itemaccountmapping
 * @property {string} ITEM_COLLECTION - itemcollection
 * @property {string} ITEM_COLLECTION_ITEM_MAP - itemcollectionitemmap
 * @property {string} ITEM_DEMAND_PLAN - itemdemandplan
 * @property {string} ITEM_FULFILLMENT - itemfulfillment
 * @property {string} ITEM_GROUP - itemgroup
 * @property {string} ITEM_LOCATION_CONFIGURATION - itemlocationconfiguration
 * @property {string} ITEM_PROCESS_FAMILY - itemprocessfamily
 * @property {string} ITEM_PROCESS_GROUP - itemprocessgroup
 * @property {string} ITEM_RECEIPT - itemreceipt
 * @property {string} ITEM_REVISION - itemrevision
 * @property {string} ITEM_SUPPLY_PLAN - itemsupplyplan
 * @property {string} JOB - job
 * @property {string} JOB_STATUS - jobstatus
 * @property {string} JOB_TYPE - jobtype
 * @property {string} JOURNAL_ENTRY - journalentry
 * @property {string} KIT_ITEM - kititem
 * @property {string} LABOR_BASED_PROJECT_REVENUE_RULE - laborbasedprojectrevenuerule
 * @property {string} LEAD - lead
 * @property {string} LOCATION - location
 * @property {string} LOT_NUMBERED_ASSEMBLY_ITEM - lotnumberedassemblyitem
 * @property {string} LOT_NUMBERED_INVENTORY_ITEM - lotnumberedinventoryitem
 * @property {string} MANUFACTURING_COST_TEMPLATE - manufacturingcosttemplate
 * @property {string} MANUFACTURING_OPERATION_TASK - manufacturingoperationtask
 * @property {string} MANUFACTURING_ROUTING - manufacturingrouting
 * @property {string} MAP_REDUCE_SCRIPT - mapreducescript
 * @property {string} MARKUP_ITEM - markupitem
 * @property {string} MASSUPDATE_SCRIPT - massupdatescript
 * @property {string} MEM_DOC - memdoc
 * @property {string} MERCHANDISE_HIERARCHY_LEVEL - merchandisehierarchylevel
 * @property {string} MERCHANDISE_HIERARCHY_NODE - merchandisehierarchynode
 * @property {string} MERCHANDISE_HIERARCHY_VERSION - merchandisehierarchyversion
 * @property {string} MESSAGE - message
 * @property {string} MFG_PLANNED_TIME - mfgplannedtime
 * @property {string} NEXUS - nexus
 * @property {string} NON_INVENTORY_ITEM - noninventoryitem
 * @property {string} NOTE - note
 * @property {string} NOTE_TYPE - notetype
 * @property {string} OPPORTUNITY - opportunity
 * @property {string} ORDER_RESERVATION - orderreservation
 * @property {string} ORDER_SCHEDULE - orderschedule
 * @property {string} ORDER_TYPE - ordertype
 * @property {string} OTHER_CHARGE_ITEM - otherchargeitem
 * @property {string} OTHER_NAME - othername
 * @property {string} OTHER_NAME_CATEGORY - othernamecategory
 * @property {string} PARTNER - partner
 * @property {string} PARTNER_CATEGORY - partnercategory
 * @property {string} PAYCHECK - paycheck
 * @property {string} PAYCHECK_JOURNAL - paycheckjournal
 * @property {string} PAYMENT_CARD - paymentcard
 * @property {string} PAYMENT_CARD_TOKEN - paymentcardtoken
 * @property {string} PAYMENT_ITEM - paymentitem
 * @property {string} PAYMENT_METHOD - paymentmethod
 * @property {string} PAYROLL_ITEM - payrollitem
 * @property {string} PCT_COMPLETE_PROJECT_REVENUE_RULE - pctcompleteprojectrevenuerule
 * @property {string} PERFORMANCE_METRIC - performancemetric
 * @property {string} PERFORMANCE_REVIEW - performancereview
 * @property {string} PERFORMANCE_REVIEW_SCHEDULE - performancereviewschedule
 * @property {string} PERIOD_END_JOURNAL - periodendjournal
 * @property {string} PHONE_CALL - phonecall
 * @property {string} PICK_STRATEGY - pickstrategy
 * @property {string} PICK_TASK - picktask
 * @property {string} PLANNED_ORDER - plannedorder
 * @property {string} PLANNING_ITEM_CATEGORY - planningitemcategory
 * @property {string} PLANNING_ITEM_GROUP - planningitemgroup
 * @property {string} PLANNING_RULE_GROUP - planningrulegroup
 * @property {string} PLANNING_VIEW - planningview
 * @property {string} PORTLET - portlet
 * @property {string} PRICE_BOOK - pricebook
 * @property {string} PRICE_LEVEL - pricelevel
 * @property {string} PRICE_PLAN - priceplan
 * @property {string} PRICING_GROUP - pricinggroup
 * @property {string} PROJECT_EXPENSE_TYPE - projectexpensetype
 * @property {string} PROJECT_IC_CHARGE_REQUEST - projecticchargerequest
 * @property {string} PROJECT_TASK - projecttask
 * @property {string} PROJECT_TEMPLATE - projecttemplate
 * @property {string} PROMOTION_CODE - promotioncode
 * @property {string} PROSPECT - prospect
 * @property {string} PURCHASE_CONTRACT - purchasecontract
 * @property {string} PURCHASE_ORDER - purchaseorder
 * @property {string} PURCHASE_REQUISITION - purchaserequisition
 * @property {string} REALLOCATE_ITEM - reallocateitem
 * @property {string} RECEIVE_INBOUND_SHIPMENT - receiveinboundshipment
 * @property {string} RESOURCE_ALLOCATION - resourceallocation
 * @property {string} RESTLET - restlet
 * @property {string} RETURN_AUTHORIZATION - returnauthorization
 * @property {string} REVENUE_ARRANGEMENT - revenuearrangement
 * @property {string} REVENUE_COMMITMENT - revenuecommitment
 * @property {string} REVENUE_COMMITMENT_REVERSAL - revenuecommitmentreversal
 * @property {string} REVENUE_PLAN - revenueplan
 * @property {string} REV_REC_FIELD_MAPPING - revrecfieldmapping
 * @property {string} REV_REC_SCHEDULE - revrecschedule
 * @property {string} REV_REC_TEMPLATE - revrectemplate
 * @property {string} SALES_CHANNEL - saleschannel
 * @property {string} SALES_ORDER - salesorder
 * @property {string} SALES_ROLE - salesrole
 * @property {string} SALES_TAX_ITEM - salestaxitem
 * @property {string} SCHEDULED_SCRIPT - scheduledscript
 * @property {string} SCHEDULED_SCRIPT_INSTANCE - scheduledscriptinstance
 * @property {string} SCRIPT_DEPLOYMENT - scriptdeployment
 * @property {string} SERIALIZED_ASSEMBLY_ITEM - serializedassemblyitem
 * @property {string} SERIALIZED_INVENTORY_ITEM - serializedinventoryitem
 * @property {string} SERVICE_ITEM - serviceitem
 * @property {string} SHIP_ITEM - shipitem
 * @property {string} SOLUTION - solution
 * @property {string} STATISTICAL_JOURNAL_ENTRY - statisticaljournalentry
 * @property {string} STORE_PICKUP_FULFILLMENT - storepickupfulfillment
 * @property {string} SUBSCRIPTION - subscription
 * @property {string} SUBSCRIPTION_CHANGE_ORDER - subscriptionchangeorder
 * @property {string} SUBSCRIPTION_LINE - subscriptionline
 * @property {string} SUBSCRIPTION_PLAN - subscriptionplan
 * @property {string} SUBSCRIPTION_TERM - subscriptionterm
 * @property {string} SUBSIDIARY - subsidiary
 * @property {string} SUBSIDIARY_SETTINGS - subsidiarysettings
 * @property {string} SUBTOTAL_ITEM - subtotalitem
 * @property {string} SUITELET - suitelet
 * @property {string} SUPPLY_CHAIN_SNAPSHOT - supplychainsnapshot
 * @property {string} SUPPLY_CHAIN_SNAPSHOT_SIMULATION - supplychainsnapshotsimulation
 * @property {string} SUPPLY_CHANGE_ORDER - supplychangeorder
 * @property {string} SUPPLY_PLAN_DEFINITION - supplyplandefinition
 * @property {string} SUPPORT_CASE - supportcase
 * @property {string} TASK - task
 * @property {string} TAX_ACCT - taxacct
 * @property {string} TAX_GROUP - taxgroup
 * @property {string} TAX_PERIOD - taxperiod
 * @property {string} TAX_TYPE - taxtype
 * @property {string} TERM - term
 * @property {string} TIME_BILL - timebill
 * @property {string} TIME_ENTRY - timeentry
 * @property {string} TIME_OFF_CHANGE - timeoffchange
 * @property {string} TIME_OFF_PLAN - timeoffplan
 * @property {string} TIME_OFF_REQUEST - timeoffrequest
 * @property {string} TIME_OFF_RULE - timeoffrule
 * @property {string} TIME_OFF_TYPE - timeofftype
 * @property {string} TIME_SHEET - timesheet
 * @property {string} TOPIC - topic
 * @property {string} TRANSFER_ORDER - transferorder
 * @property {string} UNITS_TYPE - unitstype
 * @property {string} UNLOCKED_TIME_PERIOD - unlockedtimeperiod
 * @property {string} USAGE - usage
 * @property {string} USEREVENT_SCRIPT - usereventscript
 * @property {string} VENDOR - vendor
 * @property {string} VENDOR_BILL - vendorbill
 * @property {string} VENDOR_CATEGORY - vendorcategory
 * @property {string} VENDOR_CREDIT - vendorcredit
 * @property {string} VENDOR_PAYMENT - vendorpayment
 * @property {string} VENDOR_PREPAYMENT - vendorprepayment
 * @property {string} VENDOR_PREPAYMENT_APPLICATION - vendorprepaymentapplication
 * @property {string} VENDOR_RETURN_AUTHORIZATION - vendorreturnauthorization
 * @property {string} VENDOR_SUBSIDIARY_RELATIONSHIP - vendorsubsidiaryrelationship
 * @property {string} WAVE - wave
 * @property {string} WBS - wbs
 * @property {string} WEBSITE - website
 * @property {string} WORKFLOW_ACTION_SCRIPT - workflowactionscript
 * @property {string} WORK_ORDER - workorder
 * @property {string} WORK_ORDER_CLOSE - workorderclose
 * @property {string} WORK_ORDER_COMPLETION - workordercompletion
 * @property {string} WORK_ORDER_ISSUE - workorderissue
 * @property {string} WORKPLACE - workplace
 * @property {string} ZONE - zone
 */

---- 
     /**
     * 
     * @param {SetFieldValueOptions | SetFieldTextOptions | SetSublistValueOptions | SetSublistTextOptions } options 
     * @param {FieldInputTypeEnum} options.inputType
     * @param {FieldValue} [options.value]
     * @param {FieldValue} [options.text]
     */
    function handleInputType(options) {
        /**@type {FieldValue} */
        let value = options.value || options.text || null;
        if (!options.inputType || !value) {
            writeLog(LogTypeEnum.DEBUG, `handleInputType() WARNING: at least one of options.inputType,r value is not defined.`, options.inputType, value);
            return options;
        }
        if (options.inputType === FieldInputTypeEnum.SELECT && typeof value === 'string' && !/+\d{1,}$/.test(value)) {
            // then assume that the value is the name of a record and we should set the value to the internalid of the record
        }

    }
 ----
 processSubrecordOptions() {
    ...
            /**@type {string[]} */
        const validFieldIds = rec.getFields();
        /**@type {string[]} */
        const validSublistIds = rec.getSublists();
        if (sublistId && fieldId) { // subrecord is in a sublist
            sublistId = sublistId.toLowerCase();
            fieldId = fieldId.toLowerCase();
            if (!validSublistIds.includes(sublistId)) {
                writeLog(LogTypeEnum.ERROR, `WARNING! possibly Invalid subrecordOptions.sublistId`, `sublistId: '${sublistId}' not found in ${recordType} record.getSublists() = [${validSublistIds.join(', ')}]`);
                // return rec;
            }
            /**@type {string[]} */
            const validSublistFieldIds = rec.getSublistFields({ sublistId });
            if (!validSublistFieldIds.includes(fieldId)) {
                writeLog(LogTypeEnum.ERROR, `WARNING! possibly Invalid subrecordOptions.fieldId`, `fieldId: '${fieldId}' not found in ${recordType} record.getSublistFields(${sublistId}) = [${validSublistFieldIds.join(', ')}]`);
                // return rec;
            }
            /**@type {boolean} @description line is index out of bounds if line < 0 or if line >= len(getSublist(sublistId)) */
            let lineIndexOutOfBounds = line < 0 || line >= rec.getLineCount({ sublistId });
            writeLog(LogTypeEnum.DEBUG, `processSubrecordOptions() lineIndexOutOfBounds`, `line=${line} and lineCount=${rec.getLineCount({sublistId})} -> line < 0 || line >= rec.getLineCount({ sublistId }) = ${lineIndexOutOfBounds}`);
            if (lineIndexOutOfBounds) { // then set line to new line
                line = rec.getLineCount({ sublistId });
                writeLog(LogTypeEnum.DEBUG, `rec.insertLine({sublistId: ${sublistId}, line: ${line}})`,``)
                rec.insertLine({ sublistId, line });
            }

            let subrec = rec.getSublistSubrecord({ sublistId, fieldId, line });
            writeLog(LogTypeEnum.DEBUG, `processSubrecordOptions() sublist.subrec BEFORE processFieldDictionary() = rec.getSublistSubrecord({ ${sublistId}, ${fieldId}, ${line} }) = `, subrec);
            writeLog(LogTypeEnum.DEBUG, `processSubrecordOptions() dictionary cardinality`, `Object.keys(fieldDict).length = ${subrecordFieldDict ? Object.keys(subrecordFieldDict).length : 0}, Object.keys(sublistDict).length = ${subrecordSublistDict ? Object.keys(subrecordSublistDict).length : 0}`);
            if (subrecordFieldDict && Object.keys(subrecordFieldDict).length > 0) {
                subrec = processFieldDictionary(subrec, subrecordType, subrecordFieldDict, FieldDictTypeEnum.FIELD_DICT);
            }
            if (subrecordSublistDict && Object.keys(subrecordSublistDict).length > 0) {
                subrec = processFieldDictionary(subrec, subrecordType, subrecordSublistDict, FieldDictTypeEnum.SUBLIST_FIELD_DICT);
            }
            writeLog(LogTypeEnum.DEBUG, `processSubrecordOptions() sublist.subrec AFTER processFieldDictionary() = rec.getSublistSubrecord({ sublistId, fieldId, line }) = `, subrec);
        } else if (!sublistId && fieldId) { // subrecord is in the main record
            fieldId = fieldId.toLowerCase();
            if (!validFieldIds.includes(fieldId)) {
                writeLog(LogTypeEnum.ERROR, `WARNING! possibly Invalid subrecordOptions.fieldId`, `fieldId: '${fieldId}' not found in ${recordType} record.getFields()`);
                // return rec;
            }
            
            writeLog(LogTypeEnum.DEBUG, `processSubrecordOptions() mainRec.subrec BEFORE processFieldDictionary() = rec.getSublistSubrecord({ sublistId, fieldId, line }) = `, subrec);
            writeLog(LogTypeEnum.DEBUG, `processSubrecordOptions() dictionary cardinality`, `Object.keys(fieldDict).length = ${subrecordFieldDict ? Object.keys(subrecordFieldDict).length : 0}, Object.keys(sublistDict).length = ${subrecordSublistDict ? Object.keys(subrecordSublistDict).length : 0}`);
            let subrec = rec.getSubrecord({ fieldId });
            if (subrecordFieldDict && Object.keys(subrecordFieldDict).length > 0) {
                subrec = processFieldDictionary(subrec, subrecordType, subrecordFieldDict, FieldDictTypeEnum.FIELD_DICT);
            }
            if (subrecordSublistDict && Object.keys(subrecordSublistDict).length > 0) {
                subrec = processFieldDictionary(subrec, subrecordType, subrecordSublistDict, FieldDictTypeEnum.SUBLIST_FIELD_DICT);
            }
            writeLog(LogTypeEnum.DEBUG, `processSubrecordOptions() mainRec.subrec AFTER processFieldDictionary() = rec.getSublistSubrecord({ sublistId, fieldId, line }) = `, subrec);
        }
        ...
}
------- 
            if (sublistDict || subrecords) {
                /**@type {string[]} */
                const validSublistIds = rec.getSublists();
                if (subrecords && Array.isArray(subrecords) && subrecords.length > 0) {
                    let subrec = null;
                    subrecords.forEach(({sublistId, fieldId, subrecordType, line, fieldDict: subrecFieldDict, sublistDict: subrecSublistDict}) => {
                        sublistId = sublistId ? sublistId.toLowerCase() : undefined;
                        fieldId = fieldId ? fieldId.toLowerCase() : undefined;
                        if (sublistId && fieldId && (subrecFieldDict || subrecSublistDict)) { // if subrecord is a field of a sublist
                            writeLog(LogTypeEnum.DEBUG, `Attempting to create subrecord for ${recordType}'s sublist "${sublistId}"`, `subrecordType: ${subrecordType}, fieldId: ${fieldId}, line: ${line}, Boolean(subrecFieldDict): ${Boolean(subrecFieldDict)}, Boolean(subrecSublistDict): ${Boolean(subrecSublistDict)}`);
                            if (!validSublistIds.includes(sublistId)) {
                                writeLog(LogTypeEnum.ERROR, `Invalid sublistId: "${sublistId}"`, `Sublist ID "${sublistId}" not found in ${recordType} record.`);
                                return; // continue to next subrecord
                            } 
                            // /**@type {string[]} */
                            // const validSublistFieldIds = rec.getSublistFields({ sublistId });
                            // if (!validSublistFieldIds.includes(fieldId)) {
                            //     writeLog(LogTypeEnum.ERROR, `Invalid sublist subrecord fieldId: "${fieldId}"`, `Field ID "${fieldId}" not found in ${recordType} record sublist ${sublistId}'s fields.`, validSublistFieldIds);
                            //     return; // continue to next subrecord
                            // }
                            /**@type {number} */
                            let lineCount = rec.getLineCount({ sublistId });
                            if (lineCount === 0) {
                                // writeLog(LogTypeEnum.DEBUG, `Sublist "${sublistId}" has no lines`, `Subrecord will be created on line 0`);
                                line = 0;
                                // writeLog(LogTypeEnum.DEBUG, `lineCount before insertLine: ${lineCount}`, `Inserting subrecord line at ${line}`);
                                // rec.insertLine({ sublistId, line });
                                // writeLog(LogTypeEnum.DEBUG, `lineCount after insertLine: ${rec.getLineCount({ sublistId })}`, `Subrecord line inserted at ${line}`);
                                rec.insertLine({ sublistId, line });
                            } else if (!line || line > lineCount + 1 || line < 0) {
                                // writeLog(LogTypeEnum.DEBUG, `Invalid subrecord line: ${line}`, `Line number is out of range [0, ${lineCount}-1] or undefined for sublist "${sublistId}" in "${recordType}" record, setting line to ${lineCount}`);
                                // line = lineCount;
                                // writeLog(LogTypeEnum.DEBUG, `lineCount before insertLine: ${lineCount}`, `Inserting subrecord line at ${line}`);
                                rec.insertLine({ sublistId, line });
                                // writeLog(LogTypeEnum.DEBUG, `lineCount after insertLine: ${rec.getLineCount({ sublistId })}`, `Subrecord line inserted at ${line}`);
                            }
                            subrec = rec.getSublistSubrecord({ sublistId, fieldId, line });
                            writeLog(LogTypeEnum.DEBUG, `BEFORE processFieldDictionary() calls, sublist subrec = rec.getSublistSubrecord({ ${sublistId}, ${fieldId}, ${line} })`);
                            if (subrecFieldDict && Object.keys(subrecFieldDict).length > 0) {
                                subrec = processFieldDictionary(subrec, subrecordType, subrecFieldDict, FieldDictTypeEnum.FIELD_DICT);
                            }
                            if (subrecSublistDict && Object.keys(subrecSublistDict).length > 0) {
                                subrec = processFieldDictionary(subrec, subrecordType, subrecSublistDict, FieldDictTypeEnum.SUBLIST_FIELD_DICT);
                            }
                            writeLog(LogTypeEnum.DEBUG, `AFTER processFieldDictionary() calls, sublist subrec = rec.getSublistSubrecord({ ${sublistId}, ${fieldId}, ${line} }) = `, subrec);
                            
                            try {
                                let subrecId = subrec.save();
                                writeLog(LogTypeEnum.AUDIT, `Successfully created ${subrecordType} subrecord`, { subrecordId: subrecId });
                            } catch (e) {
                                writeLog(LogTypeEnum.ERROR, `Error saving subrecord`, e);
                            }
                            // rec.commitLine({ sublistId });
                        } else if (!sublistId && fieldId && (subrecFieldDict || subrecSublistDict)) { // if subrecord is a field of the main record
                            if (!subrecFieldDict || Object.keys(subrecFieldDict).length === 0) {
                                writeLog(LogTypeEnum.ERROR, `Invalid subrecord fieldDict`, `Field dictionary is undefined or null or not an object or empty.`);
                                return; // continue to next subrecord
                            }
                            // /**@type {string[]} */
                            // const validFieldIds = rec.getFields();
                            // if (!validFieldIds.includes(fieldId)) {
                            //     writeLog(LogTypeEnum.ERROR, `Invalid subrecord fieldId: ${fieldId}`, `Field ID "${fieldId}" not found in ${recordType} record.getFields()`);
                            //     return; // continue to next subrecord
                            // }
                            subrec = rec.getSubrecord({ fieldId });
                            writeLog(LogTypeEnum.DEBUG, `subrec = rec.getSubrecord({ ${fieldId} })`, subrec);
                            writeLog(LogTypeEnum.DEBUG, `subrec.getFields()`, subrec.getFields());
                            if (subrecFieldDict && Object.keys(subrecFieldDict).length > 0) {
                                subrec = processFieldDictionary(subrec, subrecordType, subrecFieldDict, FieldDictTypeEnum.FIELD_DICT);
                            }
                            if (subrecSublistDict && Object.keys(subrecSublistDict).length > 0) {
                                writeLog(LogTypeEnum.ERROR, `Setting subrecord sublists not implemented`, `Subrecord sublist dictionary is not implemented yet.`);
                                // subrec = processFieldDictionary(subrec, subrecordType, subrecSublistDict, FieldDictTypeEnum.SUBLIST_FIELD_DICT);
                            }
                        }
                        // writeLog(LogTypeEnum.DEBUG,'sublistDict', sublistDict);
                        if (sublistDict && Object.keys(sublistDict).length > 0) {
                            for (let sublistId in Object.keys(sublistDict)) {
                                sublistId = sublistId.toLowerCase();
                                if (!validSublistIds.includes(sublistId)) {
                                    writeLog(LogTypeEnum.ERROR, `Invalid sublistId: ${sublistId}`, `Sublist ID "${sublistId}" not found in ${recordType} record.`);
                                    continue; // continue to next sublist
                                } else if (!sublistDict[sublistId] || Object.keys(sublistDict[sublistId]).length === 0) {
                                    writeLog(LogTypeEnum.ERROR, `Invalid sublistDict[${sublistId}]`, `SublistFieldDictionary is undefined or null or not an object or empty.`);
                                    continue; // continue to next sublist
                                }
                                rec = processFieldDictionary(rec, recordType, sublistDict[sublistId], FieldDictTypeEnum.SUBLIST_FIELD_DICT);
                            }
                        }
                    });
                }
            }
----
/*
interface GetSublistValueOptions {
    /** The internal ID of the sublist. 
    sublistId: string;
    /** The internal ID of a standard or custom sublist field. 
    fieldId: string;
    /** The line number for the field. 
    line: number;
}

interface GetCurrentSublistFieldOptions {
    /** The internal ID of the sublist. 
    sublistId: string;
    /** The internal ID of a standard or custom sublist field. 
    fieldId: string;
}

interface GetSublistFieldOptions {
    /** The internal ID of the sublist. 
    sublistId: string;
    /** The internal ID of a standard or custom sublist field. 
    fieldId: string;
    /** The line number for the field. 
    line: number;
}

interface HasSubrecordOptions {
    /** The internal ID of the field that may contain a subrecord. 
    fieldId: string;
}

interface InsertLineOptions {
    /** The internal ID of the sublist. 
    sublistId: string;
    /** The line number to insert. 
    line: number;
    /** If set to true, scripting recalculation is ignored. Default is false. 
    ignoreRecalc?: boolean;
}

interface MoveLineOptions {
    sublistId: string;
    from:      number;
    to:        number;
}

interface SelectLineOptions {
    /** The internal ID of the sublist. 
    sublistId: string;
    /** The line number to select in the sublist. 
    line: number;
}
    /** Almost like a full Record, except without things like save(). 
    export interface ClientCurrentRecord {
        /** Cancels the currently selected line on a sublist. 
        cancelLine(options: CancelCommitLineOptions): Record;
        cancelLine(sublistId: string): Record;
        /** Commits the currently selected line on a sublist. 
        commitLine(options: CommitLineOptions): Record;
        copy: RecordCopyFunction;
        /** Performs macro operation and returns its result in a plain JavaScript object. 
        executeMacro: ExecuteMacroFunction;
        /** Returns the line number of the first instance where a specified value is found in a specified column of the matrix. 
        findMatrixSublistLineWithValue(options: FindSublistLineWithValueOptions): number;
        /** Returns the line number for the first occurrence of a field value in a sublist. 
        findSublistLineWithValue(options: FindSublistLineWithValueOptions): number;
        /** Gets the value for the currently selected line in the matrix. 
        getCurrentMatrixSublistValue(options: GetCurrentMatrixSublistValueOptions): number | Date | string | string[] | boolean;
        /** Returns the line number of the currently selected line.   
        
        /**
         * return field object from record's sublist current line. Only available in dynamic record
         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
         * @restriction only available in dynamic record
         
        getCurrentSublistField(options: GetCurrentSublistFieldOptions): Field;
        getCurrentSublistIndex(options: RecordGetLineCountOptions): number;
        /** Gets the subrecord for the associated sublist field on the current line. 
        getCurrentSublistSubrecord(options: GetCurrentSublistValueOptions): Record;
        /** Returns a text representation of the field value in the currently selected line. 
        getCurrentSublistText(options: GetCurrentSublistValueOptions): string;
        /** Returns the value of a sublist field on the currently selected sublist line. 
        getCurrentSublistValue(options: GetCurrentSublistValueOptions): FieldValue;
        getCurrentSublistValue(sublistId: string, fieldId: string): FieldValue;
    
        
        /** 
         * Returns a field object from a record. 
         * 
         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
         
        getField(options: GetFieldOptions): Field | null;
        /** Returns the number of lines in a sublist. 
        getLineCount(options: RecordGetLineCountOptions): number;
        getLineCount(sublistId: string): number;
        /** Provides a macro to be executed. 
        getMacro(options: { id: string }): Function; // TODO: Test this!
        /** Provides a plain JavaScript object of available macro objects defined for a record type, indexed by the Macro ID. 
        getMacros(): { [macroId: string]: Macro };
        /** Returns the number of columns for the specified matrix. 
        getMatrixHeaderCount(options: GetMatrixHeaderCountOptions): number;
        /** Gets the field for the specified header in the matrix.
         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
         
        getMatrixHeaderField(options: GetMatrixHeaderFieldOptions): Field;
        /** Gets the value for the associated header in the matrix. 
        getMatrixHeaderValue(options: GetMatrixHeaderFieldOptions): FieldValue;
        /** Gets the field for the specified sublist in the matrix. 
        getMatrixSublistField(options: GetMatrixSublistFieldOptions): Field;
        /** Gets the value for the associated field in the matrix. 
        getMatrixSublistValue(options: GetMatrixSublistValueOptions): FieldValue;
        /** Returns the specified sublist. 
        getSublist(options: RecordGetLineCountOptions): Sublist;
        /**
         * Return field object from record's sublist
         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
         * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
         
        getSublistField(options: GetSublistFieldOptions): Field;
        /** Returns the value of a sublist field in a text representation. 
        getSublistText(options: GetSublistValueOptions): string;
        /** Returns the value of a sublist field. 
        getSublistValue(options: GetSublistValueOptions): FieldValue;
        getSublistValue(sublistId: string, fieldId: string, line: number): FieldValue;
        /** Gets the subrecord for the associated field. 
        getSubrecord(options: GetFieldOptions): Omit<Record, "save">;
        /** Returns the text representation of a field value. 
        getText(options: GetFieldOptions): string | string[];
        /** Returns the text representation of a field value. Warning: this is an undocumented function overload. 
        getText(fieldId: string): string | string[];
        /** Returns the value of a field. 
        getValue(options: GetFieldOptions): FieldValue;
        /** Returns the value of a field. Warning: the fieldId string parameter is an undocumented function overload. 
        getValue(fieldId: string): FieldValue;
        /** Returns a value indicating whether the associated sublist field has a subrecord on the current line. This method can only be used on dynamic records. 
        hasCurrentSublistSubrecord(options: GetCurrentSublistValueOptions): boolean;
        /** Returns a value indicating whether the associated sublist field contains a subrecord. 
        hasSublistSubrecord(options: GetSublistValueOptions): boolean;
        /** Returns a value indicating whether the field contains a subrecord. 
        hasSubrecord(options: HasSubrecordOptions): boolean;
        /**
         * The internal ID of a specific record.
         *
         * If {@link isNew} is true, this is normally null, but there are exceptions,
         * such as when {@link isNew} is true in the afterSubmit() entrypoint of a user event script.
         
        id: number | null;
        /** Inserts a sublist line. 
        insertLine(options: InsertLineOptions): this; // Issue #132
        /**
         * Indicates whether the record is in dynamic or standard mode.
         * - If set to true, the record is currently in dynamic mode. If set to false, the record is currently in standard mode.
         *  - When a SuiteScript 2.0 script creates, copies, loads, or transforms a record in standard mode, the record’s body fields and sublist line items are not sourced, calculated, and validated until the record is saved (submitted) with Record.save(options).
         *  - When you work with a record in standard mode, you do not need to set values in any particular order. After submitting the record, NetSuite processes the record’s body fields and sublist line items in the correct order, regardless of the organization of your script.
         *  - When a SuiteScript 2.0 script creates, copies, loads, or transforms a record in dynamic mode, the record’s body fields and sublist line items are sourced, calculated, and validated in real-time. A record in dynamic mode emulates the behavior of a record in the UI.
         *  - When you work with a record in dynamic mode, it is important that you set values in the same order you would within the UI. If you fail to do this, your results may not be accurate.
         * This value is set when the record is created or accessed.
         
        isDynamic: boolean;
        /** UNDOCUMENTED (as of 2023.1): This value is true when the record is being created. 
        readonly isNew: boolean;
        /** UNDOCUMENTED (as of 2023.1): Returns true if the record form cannot be edited, or false otherwise. 
        readonly isReadOnly: boolean;
        /**
         * Moves one line of the sublist to another location. The sublist machine must allow moving lines, for example: editmachine.setAllowMoveLines(true);.
         * The sublist must contain the _sequence field. The sublist type must be edit machine. When using this method, the order of the other lines is preserved.
         
        moveLine(options: MoveLineOptions): this;
        /** 
         * Removes the subrecord for the associated sublist field on the current line. 
         * @return {Record} same record, for chaining
         
        removeCurrentSublistSubrecord(options: GetCurrentSublistValueOptions): this;
        /** 
         * Removes a sublist line.
         * @return {Record} same record, for chaining 
         
        removeLine(options: InsertLineOptions): this;
        /** 
         * Removes the subrecord for the associated field. 
         * @return {Record} same record, for chaining
         
        removeSubrecord(options: GetFieldOptions): this;
        /** Selects an existing line in a sublist. 
        selectLine(options: SelectLineOptions): this;
        selectLine(sublistId: string, line: number): this;
        /** Selects a new line at the end of a sublist. 
        selectNewLine(options: RecordGetLineCountOptions): this;
        /** Sets the value for the line currently selected in the matrix. 
        setCurrentMatrixSublistValue(options: SetCurrentMatrixSublistValueOptions): Record;
        /** Sets the value for the field in the currently selected line by a text representation. 
        setCurrentSublistText(options: SetCurrentSublistTextOptions): this;
        /** Sets the value for the field in the currently selected line. 
        setCurrentSublistValue(options: SetCurrentSublistValueOptions): this;
        setCurrentSublistValue(sublistId: string, fieldId: string, value: FieldValue): this;
        /** Sets the value for the associated header in the matrix. 
        setMatrixHeaderValue(options: SetCurrentMatrixSublistValueOptions): Record;
        /** Sets the value for the associated field in the matrix. 
        setMatrixSublistValue(options: SetMatrixSublistValueOptions): Record;
        /** Sets the value of the field by a text representation. 
        setText(options: SetFieldTextOptions): this;
        setText(fieldId: string, value: string): this;
        /** Sets the value of a field. 
        setValue(options: SetValueOptions): this;
        setValue(fieldId: string, value: FieldValue): this;
    
        /** The record type. 
        readonly type: Type | `${Type}`;
    }
    
*/



----
{
    createRecordArray : CreateRecordRequest[],
    createRecordDict : {
        [K in RecordTypeEnum]?: CreateRecordRequest[]
    }
}

/**
 * @typedef {Object} LogOptions
 * @property {string} [title] - String to appear in the Title column on the Execution Log tab of the script deployment. Maximum length is 99 characters.
 * @property {any} [details] - You can pass any value for this parameter. If the value is a JavaScript object type, JSON.stringify(obj) is called on the object before displaying the value. NetSuite truncates any resulting string over 3999 characters.
 */

/**
 * @callback LogFunction
 * @param {string} [title] - The title of the log message.
 * @param {any} [details] - The details of the log message.
 * @param {LogOptions} [options] {@link LogOptions} - An object containing log options.
 * @returns {void}
 */
/**@typedef {LogFunction} debug*/
/**@typedef {LogFunction} audit*/
/**@typedef {LogFunction} error*/
/**@typedef {LogFunction} emergency*/


/**
 * @template Log
 * @implements {debug} {@link LogFunction} - Logs a debug message.
 * @implements {audit} {@link LogFunction} - Logs an audit message.
 * @implements {error} {@link LogFunction} - Logs an error message.
 * @implements {emergency} {@link LogFunction} - Logs an emergency message.
 * @reference ~\node_modules\@hitc\netsuite-types\N\log.d.ts
 */


/*
 * @example
 * logFunction('Title', 'Details');
 * logFunction({ title: 'Title', details: 'Details' });
 * @reference ~\node_modules\@hitc\netsuite-types\N\log.d.ts
 * @description A function for logging messages with different options.

*/


/**
 * Definition of Request body for the POST function in POST_BatchCreateRecord.js
 * @typedef {Object} BatchCreateRecordRequest
 * @property {Array<CreateRecordOptions>} [createRecordArray] 
 * Array<{@link CreateRecordOptions}> to create records in NetSuite.
 * - for req in BatchCreateRecordRequest.createRecordArray:
 * - - run function {@link processCreateRecordOptions}(req)
 * @property {{[K in RecordTypeEnum]?: Array<CreateRecordOptions>}} [createRecordDict] 
 * { [K in {@link RecordTypeEnum}]?: Array<{@link CreateRecordOptions}> } to create records in NetSuite.
 * - for recordType in Object.keys(BatchCreateRecordRequest.createRecordDict):
 * - - for req in BatchCreateRecordRequest.createRecordDict[recordType]:
 * - - -  run function {@link processCreateRecordOptions}(req)
*/
